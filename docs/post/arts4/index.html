<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>ARTS #4 | 林华清</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Algorithm 剑指 Offer 10- I. 斐波那契数列 key：动态规划、python不用考虑int范围
class Solution(object): def fib(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 0 if n == 1: return 1 pre1 = 0 pre2 = 1 index = 2 while index &lt;= n: pre1 , pre2 = pre2, pre1 &#43; pre2 index = index &#43; 1 return pre2 % 1000000007 Review SOLID Go Design 这篇文章讲了solid原则在go上一些最佳实践的点，主要内容如下：
 单一原则： 在go程序要做到：每个 Go package 本身就是一个小的 Go 程序，一个单一的变更单元，具有单一的责任。从package的命名、实现的内容都要做到单一功能。  这里特意提到了unix的设计理念：small, sharp tools which combine to solve larger tasks, oftentimes tasks which were not envisioned by the original authors   开闭原则：也就是Software entities should be open for extension, but closed for modification。go本身不支持函数重载。很好的做到了being open for extension, are closed for modification 里式替换原则：go本身没有抽象类的概念，但是interface很好的支持了替换原则。 接口隔离原则：Clients should not be forced to depend on methods they do not use。 在go里面的最佳实践：A great rule of thumb for Go is accept interfaces, return structs.">
    <meta name="generator" content="Hugo 0.85.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    
      

    

    
    
    <meta property="og:title" content="ARTS #4" />
<meta property="og:description" content="Algorithm 剑指 Offer 10- I. 斐波那契数列 key：动态规划、python不用考虑int范围
class Solution(object): def fib(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 0 if n == 1: return 1 pre1 = 0 pre2 = 1 index = 2 while index &lt;= n: pre1 , pre2 = pre2, pre1 &#43; pre2 index = index &#43; 1 return pre2 % 1000000007 Review SOLID Go Design 这篇文章讲了solid原则在go上一些最佳实践的点，主要内容如下：
 单一原则： 在go程序要做到：每个 Go package 本身就是一个小的 Go 程序，一个单一的变更单元，具有单一的责任。从package的命名、实现的内容都要做到单一功能。  这里特意提到了unix的设计理念：small, sharp tools which combine to solve larger tasks, oftentimes tasks which were not envisioned by the original authors   开闭原则：也就是Software entities should be open for extension, but closed for modification。go本身不支持函数重载。很好的做到了being open for extension, are closed for modification 里式替换原则：go本身没有抽象类的概念，但是interface很好的支持了替换原则。 接口隔离原则：Clients should not be forced to depend on methods they do not use。 在go里面的最佳实践：A great rule of thumb for Go is accept interfaces, return structs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://linhuaqing0928.github.io/post/arts4/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-07T20:34:48+08:00" />
<meta property="article:modified_time" content="2021-07-07T20:34:48+08:00" />

<meta itemprop="name" content="ARTS #4">
<meta itemprop="description" content="Algorithm 剑指 Offer 10- I. 斐波那契数列 key：动态规划、python不用考虑int范围
class Solution(object): def fib(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 0 if n == 1: return 1 pre1 = 0 pre2 = 1 index = 2 while index &lt;= n: pre1 , pre2 = pre2, pre1 &#43; pre2 index = index &#43; 1 return pre2 % 1000000007 Review SOLID Go Design 这篇文章讲了solid原则在go上一些最佳实践的点，主要内容如下：
 单一原则： 在go程序要做到：每个 Go package 本身就是一个小的 Go 程序，一个单一的变更单元，具有单一的责任。从package的命名、实现的内容都要做到单一功能。  这里特意提到了unix的设计理念：small, sharp tools which combine to solve larger tasks, oftentimes tasks which were not envisioned by the original authors   开闭原则：也就是Software entities should be open for extension, but closed for modification。go本身不支持函数重载。很好的做到了being open for extension, are closed for modification 里式替换原则：go本身没有抽象类的概念，但是interface很好的支持了替换原则。 接口隔离原则：Clients should not be forced to depend on methods they do not use。 在go里面的最佳实践：A great rule of thumb for Go is accept interfaces, return structs."><meta itemprop="datePublished" content="2021-07-07T20:34:48+08:00" />
<meta itemprop="dateModified" content="2021-07-07T20:34:48+08:00" />
<meta itemprop="wordCount" content="270">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ARTS #4"/>
<meta name="twitter:description" content="Algorithm 剑指 Offer 10- I. 斐波那契数列 key：动态规划、python不用考虑int范围
class Solution(object): def fib(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 0 if n == 1: return 1 pre1 = 0 pre2 = 1 index = 2 while index &lt;= n: pre1 , pre2 = pre2, pre1 &#43; pre2 index = index &#43; 1 return pre2 % 1000000007 Review SOLID Go Design 这篇文章讲了solid原则在go上一些最佳实践的点，主要内容如下：
 单一原则： 在go程序要做到：每个 Go package 本身就是一个小的 Go 程序，一个单一的变更单元，具有单一的责任。从package的命名、实现的内容都要做到单一功能。  这里特意提到了unix的设计理念：small, sharp tools which combine to solve larger tasks, oftentimes tasks which were not envisioned by the original authors   开闭原则：也就是Software entities should be open for extension, but closed for modification。go本身不支持函数重载。很好的做到了being open for extension, are closed for modification 里式替换原则：go本身没有抽象类的概念，但是interface很好的支持了替换原则。 接口隔离原则：Clients should not be forced to depend on methods they do not use。 在go里面的最佳实践：A great rule of thumb for Go is accept interfaces, return structs."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        林华清
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://linhuaqing0928.github.io/post/arts4/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://linhuaqing0928.github.io/post/arts4/&amp;text=ARTS%20#4" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://linhuaqing0928.github.io/post/arts4/&amp;title=ARTS%20#4" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">ARTS #4</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-07-07T20:34:48+08:00">July 7, 2021</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="algorithm">Algorithm</h2>
<h4 id="剑指-offer-10--i-斐波那契数列httpsleetcode-cncomproblemsfei-bo-na-qi-shu-lie-lcof"><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4>
<p>key：动态规划、python不用考虑int范围</p>
<pre><code>class Solution(object):
    def fib(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        if n == 0:
            return 0
        if n == 1:
            return 1
        pre1 = 0
        pre2 = 1
        index = 2
        while index &lt;= n:
            pre1 , pre2 = pre2, pre1 + pre2
            index = index + 1
        return pre2 % 1000000007
</code></pre><h2 id="review">Review</h2>
<p><a href="https://dave.cheney.net/2016/08/20/solid-go-design">SOLID Go Design</a>
这篇文章讲了solid原则在go上一些最佳实践的点，主要内容如下：</p>
<ul>
<li>单一原则： 在go程序要做到：每个 Go package 本身就是一个小的 Go 程序，一个单一的变更单元，具有单一的责任。从package的命名、实现的内容都要做到单一功能。
<ul>
<li>这里特意提到了unix的设计理念：small, sharp tools which combine to solve larger tasks, oftentimes tasks which were not envisioned by the original authors</li>
</ul>
</li>
<li>开闭原则：也就是Software entities should be open for extension, but closed for modification。go本身不支持函数重载。很好的做到了being open for extension, are closed for modification</li>
<li>里式替换原则：go本身没有抽象类的概念，但是interface很好的支持了替换原则。</li>
<li>接口隔离原则：Clients should not be forced to depend on methods they do not use。  在go里面的最佳实践：A great rule of thumb for Go is accept interfaces, return structs.</li>
<li>依赖注入原则（Dependency Inversion Principle）：High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.   这里提到在go里面做到依赖注入原则的一个衡量标准就是：If you have a package whose functions cannot operate without enlisting the aid of another package, that is perhaps a sign that code is not well factored along package boundaries.</li>
</ul>
<p>个人感觉在目前一般的业务代码开发中（特别是测开项目）对性能的要求其实不是那么高，反而对代码的可读性要求比较高。有一句话叫做：代码是给人看的，不是给机器看的。 而solid原则就是让我们能写出可读性高，容易重构的代码。review了下自己最近写的go代码，确实一团糟，读了这篇文章，以后尽量做到：</p>
<ol>
<li>package尽量小而单一职责。不要感觉看着功能差不多的代码就都堆到一个package里面。</li>
<li>多用组合，少用继承。多用interface，少用struct。</li>
<li>A great rule of thumb for Go is accept interfaces, return structs</li>
<li>package之间尽量独立解耦，不要互相依赖。有依赖的话，也尽量做到通过interface依赖注入，而不是package内部直接实例化使用。</li>
<li>现在代码开发为了图方便，struct内部属性全都大写对外开放，但是这样子其实是不对的 要尽量做到开闭原则。</li>
</ol>
<h2 id="tip">Tip</h2>
<p>Golang如何在application运行过程查看goroutine、heap使用情况.</p>
<ol>
<li>引入_ &ldquo;net/http/pprof&rdquo;</li>
<li>在main函数最开始的地方，开启一个goroutine进行pprof监听</li>
<li>运行main函数之后，通过浏览器打开http://127.0.0.1:9876/debug/pprof/ 其中端口号替换为代码中填写的端口号即可看到application的内存等使用情况。</li>
</ol>
<pre><code>import (
	_ &quot;net/http/pprof&quot;

	&quot;fmt&quot;
	&quot;net/http&quot;
)

func main() {
	// goroutine数量监控，正式上线需要注释掉
	go func() {
		fmt.Println(&quot;pprof start...&quot;)
		fmt.Println(http.ListenAndServe(&quot;:9876&quot;, nil))
	}()

	gin.Init()

	r := gin.Default()

	// waitFunc, mw := shutdown.New(10e9, 0)
	// r.Use(mw)
	// defer waitFunc()

	register(r)

	r.Run()

}
</code></pre><h2 id="share">Share</h2>
<p><a href="https://mp.weixin.qq.com/s/Nqr096q51NWbyN6VujFTzA">Go: GC 是怎样监听你的应用的？</a>
文章主要内容：</p>
<ol>
<li>GC会在堆内存占用douoble的时候被触发。</li>
<li>如果条件1在2分钟内没有触发，那么GC会在距离上一次GC结束时间的2分钟的时候触发一次</li>
<li>为了方便跟踪标记内存的使用情况，在GC触发的时候 GC会为每一个CPU分配一个处于 sleep 状态的 goroutine。</li>
</ol>
<p>GC还是比较难，这篇文章除了以上3点，其他的看的有点云里雾里。比如怎么标记内存使用（三色标记？）、标记阶段到底在做啥等等。 这里记一个Todo，后续再深入了解一下go得GC。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://linhuaqing0928.github.io/" >
    &copy;  林华清 2022 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
