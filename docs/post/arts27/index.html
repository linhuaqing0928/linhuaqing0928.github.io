<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>ARTS27 | 林华清</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Algorithm 剑指 Offer 40. 最小的k个数 很容易想到使用最小堆来解决这个问题，Go里面的最小堆需要实现container/heap的Interface。
import &quot;container/heap&quot; type IntHeap []int func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { result := (*h)[len(*h)-1] *h = (*h)[0 : len(*h)-1] return result } func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func getLeastNumbers(arr []int, k int) []int { result := make([]int, 0, k) initArray := &amp;IntHeap{} for _, ele := range arr { ele := ele heap.">
    <meta name="generator" content="Hugo 0.85.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    
      

    

    
    
    <meta property="og:title" content="ARTS27" />
<meta property="og:description" content="Algorithm 剑指 Offer 40. 最小的k个数 很容易想到使用最小堆来解决这个问题，Go里面的最小堆需要实现container/heap的Interface。
import &quot;container/heap&quot; type IntHeap []int func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { result := (*h)[len(*h)-1] *h = (*h)[0 : len(*h)-1] return result } func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func getLeastNumbers(arr []int, k int) []int { result := make([]int, 0, k) initArray := &amp;IntHeap{} for _, ele := range arr { ele := ele heap." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://linhuaqing0928.github.io/post/arts27/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-03T23:35:10+08:00" />
<meta property="article:modified_time" content="2022-01-03T23:35:10+08:00" />

<meta itemprop="name" content="ARTS27">
<meta itemprop="description" content="Algorithm 剑指 Offer 40. 最小的k个数 很容易想到使用最小堆来解决这个问题，Go里面的最小堆需要实现container/heap的Interface。
import &quot;container/heap&quot; type IntHeap []int func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { result := (*h)[len(*h)-1] *h = (*h)[0 : len(*h)-1] return result } func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func getLeastNumbers(arr []int, k int) []int { result := make([]int, 0, k) initArray := &amp;IntHeap{} for _, ele := range arr { ele := ele heap."><meta itemprop="datePublished" content="2022-01-03T23:35:10+08:00" />
<meta itemprop="dateModified" content="2022-01-03T23:35:10+08:00" />
<meta itemprop="wordCount" content="253">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ARTS27"/>
<meta name="twitter:description" content="Algorithm 剑指 Offer 40. 最小的k个数 很容易想到使用最小堆来解决这个问题，Go里面的最小堆需要实现container/heap的Interface。
import &quot;container/heap&quot; type IntHeap []int func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { result := (*h)[len(*h)-1] *h = (*h)[0 : len(*h)-1] return result } func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func getLeastNumbers(arr []int, k int) []int { result := make([]int, 0, k) initArray := &amp;IntHeap{} for _, ele := range arr { ele := ele heap."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        林华清
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://linhuaqing0928.github.io/post/arts27/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://linhuaqing0928.github.io/post/arts27/&amp;text=ARTS27" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://linhuaqing0928.github.io/post/arts27/&amp;title=ARTS27" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">ARTS27</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-03T23:35:10+08:00">January 3, 2022</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="algorithm">Algorithm</h2>
<h4 id="剑指-offer-40-最小的k个数httpsleetcode-cncomproblemszui-xiao-de-kge-shu-lcof"><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4>
<p>很容易想到使用最小堆来解决这个问题，Go里面的最小堆需要实现container/heap的Interface。</p>
<pre><code>import &quot;container/heap&quot;

type IntHeap []int

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	result := (*h)[len(*h)-1]
	*h = (*h)[0 : len(*h)-1]
	return result
}

func (h IntHeap) Len() int {
	return len(h)
}

func (h IntHeap) Less(i, j int) bool {
	return h[i] &lt; h[j]
}

func (h IntHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func getLeastNumbers(arr []int, k int) []int {
	result := make([]int, 0, k)
	initArray := &amp;IntHeap{}
	for _, ele := range arr {
		ele := ele
		heap.Push(initArray, ele)
		// heap.Init(initArray)
		if initArray.Len() &gt; len(arr)-k {
			temp := heap.Pop(initArray).(int)
			result = append(result, temp)
		}
	}
	return result
}
</code></pre><h2 id="review">Review</h2>
<p><a href="https://medium.com/nerd-for-tech/unique-id-generation-in-distributed-systems-6f7aaa39c9af">Unique Id generation in distributed systems</a>
文章首先科普了下啥是分布式ID生成器，然后介绍了Twitter snowflake的实现原理，最后自己手动实现了一个简易版ID生成器（原理完全按照Twitter snowflake来实现）</p>
<ol>
<li>如果对Mysql进行分库的话，如果直接使用MySql的自增ID来当作主键的话，不同数据库分片的主键就会有冲突。这时候就需要一个分布式ID生成器服务来提供unique ID。</li>
<li>Twitter snowflake的原理与构成：</li>
</ol>
<ul>
<li>Epoch timestamp in millisecond — 41 bits (gives us 69 years with respect to any custom epoch)</li>
<li>Configured machine/node/shard Id — 10 bits (gives us up to a total of 2^10 i.e 1024 Ids)</li>
<li>Sequence number — 12 bits (A local counter per machine that sets to zero after every 4096 values)</li>
<li>The extra 1 reserved bit at the beginning is set as 0 to make the overall number as positive.</li>
</ul>
<ol start="3">
<li>自己实现一个简易版的分布式ID生成器。关键方法：</li>
</ol>
<ul>
<li>nextId方法。这个方法需要加锁，主要工作就是拼接时间戳、node ID、序列号生成ID。</li>
<li>createNodeId。通过服务器的mac生成node ID。</li>
<li>分布式ID生成器在单个实例生需要是单例的，不然序列号和node ID就会一致，最终导致可能生成的分布式ID会冲突。</li>
</ul>
<h2 id="tip">TIP</h2>
<p>这周工作过程用到了go vendor，了解到了几个基本的概念和用法。</p>
<ol>
<li>vendor模式下，会优先使用去当前仓库的vendor目录下寻找依赖的SDK。如果找不到再去GoPath路径的src目录下寻找依赖。</li>
<li>govendor get xxx会安装并将依赖的SDK源码copy到当前仓库的vendor目录下，这时候vendor.json会新增这个依赖的相关信息。</li>
<li>govendor add会将已经安装的依赖copy到当前仓库的vendor目录下，这时候vendor.json会新增这个依赖的相关信息。相比govendor get，只会执行copy的动作。</li>
<li>在go mod仓库下，使用go mod vendor会在root目录下生成vendor目录，并将go.mod的所有依赖copy到vendor目录下。</li>
</ol>
<h2 id="share">Share</h2>
<p>继续学习“操作系统32讲”</p>
<h3 id="l3-操作系统启动">L3 操作系统启动</h3>
<h4 id="启动过程">启动过程</h4>
<ol>
<li>引导扇区的bootsect.s会分段将磁盘上的操作系统代码读取到内存中。先读取setup模块，然后读取system模块的代码，然后执行setup和system模块。</li>
<li>setup模块是一段汇编代码，主要做的工作就是将操作系统基础信息建立起来。会做以下动作：</li>
</ol>
<ul>
<li>读取光标位置</li>
<li>读取扩展内存数</li>
<li>读取显卡参数</li>
<li>读取根设备号</li>
<li>将操作系统system模块挪到0x0000-0x7c00 和后续应用层代码的内存段区分开</li>
<li>通过执行mov ax,#0x0001 mov cr0,ax来将当前系统置为保护模式（32位机模式）。在这个阶段之前，系统的寻址方式是cs:ip模式（cs&laquo;4+ip，cs指的是段寄存器，ip指的是ip寄存器，都是16位的寄存器。能访问的内存地址是2的20次方，也就是1M的内存），这个模式是16位机。</li>
<li>然后通过jmpi 0,8 跳转到system模块所在的内存地址。</li>
</ul>
<ol start="3">
<li>执行system模块代码</li>
</ol>
<ul>
<li>执行head.s。head.s是一段汇编代码，是system的第一个文件。再次初始化gdt表。</li>
<li>执行main.c。main.c是一段c代码。main函数做了一系列的init函数，包括内存、中断、设备、时钟、cpu等内容。其中mem_init（内存初始化）做的工作是初始化一个mem_map数组来存储内存地址是否使用。</li>
</ul>
<h4 id="小tips">小tips</h4>
<p>cs:ip寻址方式和保护模式的寻址方式的差别</p>
<ol>
<li>cs:ip模式cs寄存器里面直接存的是指令内存地址，而保护模式下cs寄存器下存放的是gdt table的数组下标。保护模式的cs寄存器被称为selector。</li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://linhuaqing0928.github.io/" >
    &copy;  林华清 2022 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
