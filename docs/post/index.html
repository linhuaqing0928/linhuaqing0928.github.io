<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>林华清</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.85.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    
      

    

    
    
      <link href="/post/index.xml" rel="alternate" type="application/rss+xml" title="林华清" />
      <link href="/post/index.xml" rel="feed" type="application/rss+xml" title="林华清" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://linhuaqing0928.github.io/post/" />

<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        林华清
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      

  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray">
      
    </section>
    <aside class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        December 6, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts24/" class="link black dim">
        ARTS24
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 18. 删除链表的节点 // Definition for singly-linked list. type ListNode struct { Val int Next *ListNode } func deleteNode(head *ListNode, val int) *ListNode { if head.Val == val { return head.Next } result := head for { if head.Next == nil { break } if head.Next.Val == val { head.Next = head.Next.Next break } head = head.Next } return result } Review When Do Programmers Retire? Is 35 the End?
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        November 28, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts23/" class="link black dim">
        ARTS23
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 13. 机器人的运动范围  题目关键是它每次可以向左、右、上、下移动一格（不能移动到方格外）。理解了这个之后就是DFS就好了。 遍历过程维护一个map，存已经经过的点。  func movingCount(m int, n int, k int) int { result := 0 done := make(map[[2]int]int) dfs(0, 0, m, n, k, &amp;result, done) return result } func dfs(rowIndex, columnIndex, m, n, k int, count *int, done map[[2]int]int) { if rowIndex &gt;= m || columnIndex &gt;= n { return } if !enterPermission(rowIndex, columnIndex, k) { return } temp := [2]int{} temp[0] = columnIndex temp[1] = rowIndex _, ok := done[temp] if ok { return } done[temp] = 1 *count++ dfs(rowIndex, columnIndex+1, m, n, k, count, done) dfs(rowIndex+1, columnIndex, m, n, k, count, done) return } func enterPermission(rowIndex int, columnIndex int, k int) bool { return (numberSum(rowIndex) + numberSum(columnIndex)) &lt;= k } func numberSum(input int) int { a := input / 100 input = input % 100 b := input / 10 input = input % 10 return a + b + input } Review Context in Go 文章简单介绍了go标准库的context包，都是一些基本用法，刚好最近做需求频繁的用到context，复习一下。建议直接看标准库源码，注释写的很清晰。
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        November 21, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts22/" class="link black dim">
        ARTS22
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 17. 打印从1到最大的n位数 func printNumbers(n int) []int { count := math.Pow(10, float64(n)) result := make([]int, int(count-1)) index := 1 for index &lt; int(count) { result[index-1] = index index++ } return result } Review 5 Lessons That Golang Teaches To All Programmers 文章讲述了Go语言值得借鉴的几个特点：
 不过度设计。Go语言的设计理念确实一直是能简单就简单，less is more。不止是体现在文章里面举例的只有25个关键字、不提供while/for条件、不提供三元表达式等语言特性，还体现在官方一直宣扬的理念。比如不提供map和reduce等函数式常用方法、不鼓励使用运行时反射实现依赖注入而是通过wire生成代码的方式实现依赖注入。简单不过度设计就意味着代码可读性、性能好。 尽量不动核心代码。这个大家工作都应该深有感触，核心代码尽量少动。 使用Error处理错误，而不是Exception抛出。好处是让程序员充分考虑清楚整个数据流、错误场景。坏处就是代码里面一堆的 if err != nil。。 不用OOP也能解决问题。不要太纠结于面向对象，重要的是代码的解耦、可复用性、可读性。 多考虑考虑解决问题的各种方法。  TIP 这周学会了怎么使用grafana来可视化查看ES的数据
 建立data sources，指定数据索引 写query，查询出对应数据 选择对应数据作为X/Y轴即可  Share GO 编程模式：FUNCTIONAL OPTIONS Golang中常见的option设计探讨
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        November 14, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts21/" class="link black dim">
        ARTS21
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 22. 链表中倒数第k个节点  最简单的方法，遍历链表 然后每个节点存储在map里面，最后按照key取出来倒数第K个节点 快慢指针方法 快指针比慢指针早出发K-1个节点 这样子当快指针达到尾节点的时候，慢指针就是我们期望的结果  // map存储法 func getKthFromEnd(head *ListNode, k int) *ListNode { if head == nil { return nil } nodes := make(map[int]*ListNode) count := 1 for { nodes[count] = head if head.Next != nil { head = head.Next count++ } else { break } } result := nodes[count-k+1] return result } // 快慢指针方法 func getKthFromEnd1(head *ListNode, k int) *ListNode { if head == nil { return nil } slow := head fast := head index := 1 for { if fast.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        November 7, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts20/" class="link black dim">
        ARTS20
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 28. 对称的二叉树 // Definition for a binary tree node. type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func isSymmetric(root *TreeNode) bool { if root == nil { return true } return symmetric([]*TreeNode{root.Left, root.Right}) } func symmetric(roots []*TreeNode) bool { length := len(roots) index := 0 for index &lt; length/2 { temp1 := roots[index] temp2 := roots[length-1-index] if temp1 != nil &amp;&amp; temp2 != nil &amp;&amp; temp1.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        October 7, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts19/" class="link black dim">
        ARTS19
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 14- II. 剪绳子 II 这道题比剪绳子|难在绳子长度范围可以达到1000，并且需要取模。如果是直接计算的话，就算是int64也会溢出，所以需要循环取模。
func cuttingRope(n int) int { var result int if n == 2 { return 1 } if n == 3 { return 2 } remind := n % 3 if remind == 0 { // result = int(math.Pow(3, float64(n/3))) % 1000000007 result = getRemind(n/3) % 1000000007 } if remind == 1 { // result = int(math.Pow(3, float64(n/3)-1)) * 4 % 1000000007 result = getRemind(n/3-1) * 4 % 1000000007 } if remind == 2 { // result = int(math.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        October 4, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts18/" class="link black dim">
        ARTS18
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 14- I. 剪绳子 2种解法：
 贪心法，从长度为2的绳子开始找规律 可以知道每次得到越多的3的时候 乘积越大。这个解法是自己解出来的。 动态规划，看其他人借题答案学到的。关键点动态规划点就是每次先剪去一段长度，然后剩下的有剪或者不剪2种方法，取max。转移方程为：dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))  // 贪心算法 找规律，可以得到将内容划分为3的时候 得到的乘积为最大 func cuttingRope1(n int) int { var result int if n == 2 { return 1 } if n == 3 { return 2 } remind := n % 3 if remind == 0 { result = int(math.Pow(3, float64(n/3))) } if remind == 1 { result = int(math.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        September 26, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts17/" class="link black dim">
        ARTS17
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 29. 顺时针打印矩阵 func spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return nil } result := make([]int, 0, len(matrix)*len(matrix[0])) xMin := 0 yMin := 1 // 这里需要注意，Y轴刚起步就占用了一个，所以初始为1 yMax := len(matrix) xMax := len(matrix[0]) x := 0 // 代表X轴 y := 0 // 代表Y轴 flag := true // true代表横着走，false代表竖着走 count := 1 // 1代表正向走，-1达标逆向走 for { if flag { if x &lt; xMin || x &gt;= xMax { break } } else { if y &lt; yMin || y &gt;= yMax { break } } result = append(result, matrix[y][x]) // 专项判断 if flag { xTemp := x + count if xTemp &gt;= xMax { flag = false count = 1 xMax-- } else if xTemp &lt; xMin { flag = false count = -1 xMin++ } } else if !
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        September 21, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts16/" class="link black dim">
        ARTS16
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 15. 二进制中1的个数  自己的解法：不断的除和求余 官方解法：与运算  func hammingWeight1(num uint32) int { count := 0 index := 31 for index &gt;= 0 { multi := num / (uint32(math.Pow(2, float64(index)))) if multi == 1 { count++ } num = num % (uint32(math.Pow(2, float64(index)))) index-- } return count } func hammingWeight2(num uint32) int { count := 0 index := 0 for index &lt; 32 { if 1&lt;&lt;index&amp;num &gt; 0 { count++ } index++ } return count } Review Golang: Six Error Handling techniques to help you write elegant code 文章比较细，介绍了作者个人比较推荐的几个error处理方式。感觉比较有用的2点：
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        September 21, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts15/" class="link black dim">
        ARTS15
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 12. 矩阵中的路径 自己用stack的方式解法，思路和官方是一样的，但是一直不能ac，后面留时间再debug下。 贴一下Golang实现的官方解题：
func exist(board [][]byte, word string) bool { row := 0 for row &lt; len(board) { column := 0 for column &lt; len(board[0]) { if dfs(row, column, 0, &amp;board, word) { return true } column++ } row++ } return false } func dfs(i int, j int, k int, board *[][]byte, word string) bool { if !(0 &lt;= i &amp;&amp; i &lt; len(*board)) || !(0 &lt;= j &amp;&amp; j &lt; len((*board)[0])) || ((*board)[i][j] !
    </div>
  </div>

        </div>
      
    </aside>
    
    <ul class="pagination pagination-default">
      <li class="page-item disabled">
        <a href="#" aria-disabled="true" aria-label="First" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item disabled">
        <a href="#" aria-disabled="true" aria-label="Previous" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item active">
        <a href="#" aria-current="page" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item">
        <a href="/post/page/2/" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/post/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item">
        <a href="/post/page/2/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/post/page/3/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://linhuaqing0928.github.io/" >
    &copy;  林华清 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
