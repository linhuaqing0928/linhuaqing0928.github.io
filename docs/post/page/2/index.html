<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>林华清</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.85.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    
      

    

    
    
      <link href="/post/index.xml" rel="alternate" type="application/rss+xml" title="林华清" />
      <link href="/post/index.xml" rel="feed" type="application/rss+xml" title="林华清" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://linhuaqing0928.github.io/post/" />

<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        林华清
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      

  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray">
      
    </section>
    <aside class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        September 21, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts15/" class="link black dim">
        ARTS15
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 12. 矩阵中的路径 自己用stack的方式解法，思路和官方是一样的，但是一直不能ac，后面留时间再debug下。 贴一下Golang实现的官方解题：
func exist(board [][]byte, word string) bool { row := 0 for row &lt; len(board) { column := 0 for column &lt; len(board[0]) { if dfs(row, column, 0, &amp;board, word) { return true } column++ } row++ } return false } func dfs(i int, j int, k int, board *[][]byte, word string) bool { if !(0 &lt;= i &amp;&amp; i &lt; len(*board)) || !(0 &lt;= j &amp;&amp; j &lt; len((*board)[0])) || ((*board)[i][j] !
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        September 5, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts14/" class="link black dim">
        ARTS14
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 2个解法：
 头尾双指针   2个指针分别从头尾出发 判断头指针所在位置的值是奇数还是偶数 如果是奇数，则头指针++然后continue 如果是偶数，则交换头尾指针所在位置数组的数值。然后尾指针&ndash;，continue。  快慢双指针   2个指针一起从头部出发 判断快指针所在位置的值是奇数还是偶数 如果是奇数，则交换快慢指针所在位置数组的数值，然后快慢指针都++，continue。 如果是偶数，则快指针++ 然后continue  // 首位双指针 func exchange1(nums []int) []int { start := 0 end := len(nums) - 1 for start &lt; end { if nums[start]%2 == 1 { start++ continue } if nums[start]%2 == 0 { temp := nums[start] nums[start] = nums[end] nums[end] = temp end-- continue } } return nums } // 快慢双指针 func exchange(nums []int) []int { slow := 0 fast := 0 for fast &lt; len(nums) { if nums[fast]%2 == 1 { temp := nums[fast] nums[fast] = nums[slow] nums[slow] = temp fast++ slow++ continue } if nums[fast]%2 == 0 { fast++ continue } } return nums } Review Provider Pattern in Go and Why You Should Use It 文章讲述了provider模式的好处：
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        August 29, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts13/" class="link black dim">
        ARTS13
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 10- II. 青蛙跳台阶问题 简单动态规划题目，注意边界值和取模即可
func numWays(n int) int { if n &lt; 2 { return 1 } result := make([]int, n+1) result[0] = 1 result[1] = 1 index := 2 for index &lt;= n { result[index] = result[index-1] + result[index-2] result[index] = result[index] % 1000000007 index++ } return result[n] } Review Go: Understand the Empty Interface 文章介绍了Golang的interface{}的底层实现：
 Golang的runtime源码中，有一个专门的emptyInterface的结构体来表示interface{}。其实就是2个指针：一个代表这个interface的内置type，另一个则是存具体数据内容的指针。前者里面存了内置type具体的size、kind等内容。  type emptyInterface struct { typ *rtype // word 1 with type description word unsafe.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        August 22, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts12/" class="link black dim">
        ARTS12
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 11. 旋转数组的最小数字  解法1：暴力破解法，从前往后遍历，如果index+1比index小就return 解法2：二分法。关键点就是数组本身是一个旋转数组，也就是半递增数组。所以以中间一个最小值点为边界，最小值左右侧都是递增的。通过拿mid点和最右侧点进行对比：   如果mid比right小，说明最小值不在右侧。 如果mid比right大，说明最小值不在左侧。 如果mid和right一样大小，说明存在重复元素。由于我们不知道重复元素有多少个，所以我们right&ndash;即可。  // 暴力遍历，时间复杂度O(n) func minArray1(numbers []int) int { length := len(numbers) index := 0 for index &lt; length-1 { if numbers[index] &gt; numbers[index+1] { return numbers[index+1] } index++ } return numbers[0] } // 二分法，时间复杂度O(logn) // 关键在于 func minArray(numbers []int) int { left := 0 right := len(numbers) - 1 for left &lt; right { mid := left + (right-left)/2 if numbers[mid] &lt; numbers[right] { right = mid continue } if numbers[mid] &gt; numbers[right] { left = mid + 1 continue } if numbers[mid] == numbers[right] { right-- continue } } return numbers[left] } Review Go Pointers: Why I Use Interfaces (in Go) 文章举了一个在Golang中使用interface的例子，来安利我们“面向interface编程“。
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        August 16, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts11/" class="link black dim">
        ARTS11
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 本周听同组同学新人串讲，提到了计算表达式相关知识点，所以上leetcode找出题目，复习写了下。
224. 基本计算器 func calculate(s string) int { s = strings.ReplaceAll(s, &quot; &quot;, &quot;&quot;) var result int intStack := list.New() intStack.PushBack(0) oprateStack := list.New() start := 0 end := start + 1 for end &lt;= len(s) { if s[start:end] == &quot;(&quot; { oprateStack.PushBack(&quot;(&quot;) start = end end = start + 1 continue } if s[start:end] == &quot;-&quot; || s[start:end] == &quot;+&quot; { if start &gt; 0 &amp;&amp; (s[start-1:start] == &quot;-&quot; || s[start-1:start] == &quot;+&quot; || s[start-1:start] == &quot;(&quot;) { intStack.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        August 8, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts10/" class="link black dim">
        ARTS10
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 27. 二叉树的镜像 比较简单的二叉树题目，分别使用递归和栈实现了下
import &quot;container/list&quot; // Definition for a binary tree node. type TreeNode struct { Val int Left *TreeNode Right *TreeNode } // 递归算法 func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } if root.Left == nil &amp;&amp; root.Right == nil { return root } temp := root.Left root.Left = root.Right root.Right = temp if root.Right != nil { mirrorTree(root.Right) } if root.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        August 1, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts9/" class="link black dim">
        ARTS9
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 25. 合并两个排序的链表 解法1：起一个新的链表。然后双指针遍历2个链表，不断地new新的ListNode，并添加到新的链表中。 解法2：三指针解法。将2个链表合并为一个结果链表。
 指针A指向合并后的链表的当前位置。 另外2个指针B、C指向未合并前的2个链表的Next节点位置。当其中一个指针达到尾部之后，将指针A的Next指向另一个指针即可。  package merge_two_lists //Definition for singly-linked list. type ListNode struct { Val int Next *ListNode } func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil &amp;&amp; l2 == nil { return nil } if l1 == nil { return l2 } if l2 == nil { return l1 } var result, current *ListNode if l1.Val &lt;= l2.Val { current = l1 l1 = l1.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        August 1, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%E4%BA%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E6%94%B9%E9%80%A0/" class="link black dim">
        Golang单元测试实战二：依赖注入与面向接口改造
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      单元测试  Unit tests should be pretty lightweight and run fast since they don’t depend on anything external to the unit of code being tested The only way they can fail is by changing the unit of code they are testing  过程 待单元测试代码：
func (f FileSDK) NewFile() string { myClient := ThridPClient{} _, err := myClient.GetRemoteFile() // do something if err.Error() == &quot;error1&quot; { return &quot;default1.txt&quot; } if err.Error() == &quot;error2&quot; { return &quot;default2.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        July 25, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts8/" class="link black dim">
        ARTS8
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 07. 重建二叉树 这道题没有做出来，看了官方解答之后用Golang写一遍 递归法：
type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func buildTree(preorder []int, inorder []int) *TreeNode { // 遍历中序数组并将数据放到map中，方便后续读取数据 index := 0 treeMap := make(map[int]int) for ; index &lt; len(inorder); index++ { treeMap[inorder[index]] = index } head := buildTreeWithIndex(0, len(preorder)-1, 0, len(preorder)-1, preorder, inorder, treeMap) return head } func buildTreeWithIndex(preorderLeft, preorderRight, inorderLeft, inorderRight int, preorder []int, inorder []int, treeMap map[int]int) *TreeNode { if preorderLeft &gt; preorderRight { return nil } preorderRoot := preorderLeft inorderRoot := treeMap[preorder[preorderRoot]] inorderLeftSize := inorderRoot - inorderLeft head := &amp;TreeNode{preorder[preorderRoot], nil, nil} head.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        July 18, 2021
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://linhuaqing0928.github.io/post/arts7/" class="link black dim">
        ARTS7
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Algorithm 剑指 Offer 06. 从尾到头打印链表 简单的反转单向链表，之前面试字节的时候遇到过，结果当时没做出来。。 这里比官方解法少一点时间复杂度。
package reverse_print // Definition for singly-linked list. type ListNode struct { Val int Next *ListNode } func reversePrint(head *ListNode) []int { if head == nil { return nil } var next *ListNode var prev *ListNode for true { if head.Next != nil { next = head.Next head.Next = prev prev = head head = next continue } head.Next = prev break } var result []int for true { result = append(result, head.
    </div>
  </div>

        </div>
      
    </aside>
    
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/post/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/post/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/post/" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item active">
        <a href="#" aria-current="page" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/post/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item">
        <a href="/post/page/3/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/post/page/3/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://linhuaqing0928.github.io/" >
    &copy;  林华清 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
